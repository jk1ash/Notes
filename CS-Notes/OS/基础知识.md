## 死锁
### 产生死锁的四个条件

1. 互斥条件（Mutual exclusion）

> 资源不能被共享，只能由一个进程使用。


2. 请求与保持条件（Hold and wait）

> 已经得到资源的进程可以再次申请新的资源。


3. 不可剥夺条件（No pre-emption）

> 已经分配的资源不能从相应的进程中被强制地剥夺。


4. 环路/循环等待条件（Circular wait）

> 系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。


### 预防死锁

1. 预先资源分配法

一次性申请所有需要的资源，只要有一种资源不满足要求，哪怕其它需要的资源都足够，也不做任何分配。这样一来就没有“保持”资源的状态，只有“请求”资源的状态，破坏了请求与保持条件。

2. 有序资源分配法

在申请不同类资源时，必须按指定顺序申请，破坏了环路等待条件。

- 正例：线程A、B申请资源顺序均为R1->R2；
- 反例：A申请顺序为R1->R2，B申请顺序为R2->R1。

### 避免死锁

**银行家算法**

基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。

### 检测死锁和解除

不采取措施防止死锁产生，允许系统产生死锁，但是可以通过一些手段检测出死锁，然后将死锁解除。

**检测方法：**

1. 定时检测
2. 效率低时检测
3. 进程等待时检测

**解除死锁方法**：

根据具体业务场景，可以撤销或挂起死锁的进程/线程，使资源释放。

## 进程和线程