### 一、创建型模式

**1. 单例模式 (Singleton Pattern)**

- **目的**：确保一个类只有一个实例，并提供一个全局访问点。
- **特点**：通过私有构造函数控制实例化，通常采用懒加载（延迟初始化）和线程安全措施来防止多线程环境下创建多个实例。
- **使用场景**：日志记录器、配置管理、连接池等需要全局唯一访问的场景。

**2. 工厂方法模式 (Factory Method Pattern)**

- **目的**：定义一个用于创建对象的接口，让子类决定实例化哪一个类。这样可以将对象的创建延迟到子类。
- **特点**：解耦具体产品类和调用者；符合“开闭原则”，易于扩展。
- **使用场景**：当一个类不知道它所必须创建的对象的具体类型，或者希望将创建过程委托给子类时。

**3. 抽象工厂模式 (Abstract Factory Pattern)**

- **目的**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类。
- **特点**：确保产品族的一致性；通过封装产品的创建细节使得系统更易于扩展和维护。
- **使用场景**：跨平台开发、UI组件库等需要针对不同平台或风格生成不同产品的场景。

**4. 建造者模式 (Builder Pattern)**

- **目的**：将一个复杂对象的构建过程与其表示分离，使得相同的构建过程可以创建不同的表示。
- **特点**：将对象的构建步骤分离，避免构造函数参数过多；便于对象的灵活组合和配置。
- **使用场景**：构建复杂对象，如配置复杂参数的对象（例如：图形界面、文档生成）。

**5. 原型模式 (Prototype Pattern)**

- **目的**：通过复制现有实例来创建新的对象，而不是通过传统的“new”操作创建实例。
- **特点**：避免创建对象时的开销；能够动态地复制对象；适用于对象创建代价较大的场景。
- **使用场景**：需要复制对象状态，或者对象创建过程复杂耗时时，例如对象池技术。

---

### 二、结构型模式

**6. 适配器模式 (Adapter Pattern)**

- **目的**：将一个类的接口转换成客户期望的另一个接口，使得原本不兼容的类可以一起工作。
- **特点**：通过包装原有对象，实现接口转换；提高了类的复用性和灵活性。
- **使用场景**：需要整合遗留系统或第三方库时，统一接口调用。

**7. 装饰器模式 (Decorator Pattern)**

- **目的**：动态地给对象添加新的职责，而不改变其接口，提供比继承更灵活的功能扩展方式。
- **特点**：可以在运行时叠加多个装饰器；符合开闭原则；避免子类爆炸。
- **使用场景**：需要在不影响其他对象的情况下为对象增加额外功能，如图形界面组件的装饰、日志记录等。

**8. 代理模式 (Proxy Pattern)**

- **目的**：为其他对象提供一种代理，以控制对这个对象的访问。
- **特点**：可以在访问实际对象前后增加额外处理，如延迟加载、访问控制、日志记录等。
- **使用场景**：远程代理、虚拟代理、安全代理、智能引用等场景中，经常用来优化性能或增加安全性。

**9. 外观模式 (Facade Pattern)**

- **目的**：为一组复杂的子系统提供一个统一的接口，简化子系统的使用。
- **特点**：降低系统的复杂度和耦合度；提供一个高层次接口。
- **使用场景**：当系统存在复杂交互或多个子系统时，通过外观模式简化对外接口，便于使用和维护。

**10. 桥接模式 (Bridge Pattern)**

- **目的**：将抽象部分与其实现部分分离，使它们可以独立地变化。
- **特点**：降低了抽象与实现之间的耦合，便于扩展；使得系统具备更高的灵活性。
- **使用场景**：当抽象和实现都需要扩展，而且两者之间可能会独立变化时，如设备驱动程序、图形绘制等。

**11. 组合模式 (Composite Pattern)**

- **目的**：将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户端可以一致地对待单个对象和组合对象。
- **特点**：简化客户端调用；递归结构；容易扩展和管理。
- **使用场景**：文件系统、组织架构、图形界面容器等需要处理树形结构的场景。

**12. 享元模式 (Flyweight Pattern)**

- **目的**：运用共享技术有效地支持大量细粒度对象，减少内存使用。
- **特点**：区分对象的内在状态（可以共享）和外在状态（不可共享）；显著降低内存开销。
- **使用场景**：当需要大量细粒度对象且这些对象大部分状态可以共享时，如字符显示、对象池等。

---

### 三、行为型模式

**13. 策略模式 (Strategy Pattern)**

- **目的**：定义一系列算法，将每个算法封装起来，使它们可以相互替换，让算法的变化独立于使用它的客户。
- **特点**：消除大量条件判断；易于扩展新的策略；策略可以在运行时动态切换。
- **使用场景**：需要在运行时选择不同算法或行为时，如排序算法、压缩算法等。

**14. 模板方法模式 (Template Method Pattern)**

- **目的**：定义算法骨架，将一些步骤延迟到子类中实现，从而在不改变算法结构的前提下重新定义某些步骤。
- **特点**：提高代码复用；减少重复代码；子类只需要实现特定步骤。
- **使用场景**：当多个子类具有大部分相同的逻辑但又需要在某些步骤上有不同实现时，如数据处理流程、游戏引擎中的行为定义。

**15. 观察者模式 (Observer Pattern)**

- **目的**：定义对象之间的一种一对多依赖关系，当一个对象状态发生改变时，其所有依赖者都会收到通知并自动更新。
- **特点**：实现松耦合；支持广播通信；便于动态添加和删除观察者。
- **使用场景**：事件驱动系统、MVC 架构、消息系统等，常用于需要及时通知相关对象状态变化的场合。

**16. 迭代器模式 (Iterator Pattern)**

- **目的**：提供一种方法顺序访问聚合对象中的各个元素，而又不暴露对象的内部表示。
- **特点**：隐藏集合的内部结构；统一遍历接口；支持多种遍历方式。
- **使用场景**：集合类、数据结构的遍历，如数组、链表、树等数据结构。

**17. 责任链模式 (Chain of Responsibility Pattern)**

- **目的**：使多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链传递请求，直到有对象处理它。
- **特点**：降低请求发送者与接收者的耦合；使得请求的处理更加灵活。
- **使用场景**：审批流程、事件处理、日志记录等需要多级处理的场景。

**18. 命令模式 (Command Pattern)**

- **目的**：将请求封装成对象，使你可以用不同的请求对客户进行参数化，并支持请求的队列、撤销等操作。
- **特点**：将调用者和执行者解耦；易于实现日志记录、撤销/重做操作。
- **使用场景**：需要对操作进行记录、撤销、重做或远程请求时，如事务处理、UI 按钮的操作等。

**19. 备忘录模式 (Memento Pattern)**

- **目的**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在以后恢复该对象到之前的状态。
- **特点**：保存和恢复对象状态；对外部不暴露对象的内部实现细节。
- **使用场景**：实现撤销/回滚操作，如文本编辑器的撤销功能。

**20. 状态模式 (State Pattern)**

- **目的**：允许对象在其内部状态改变时改变其行为，使得对象看起来好像修改了它的类。
- **特点**：消除大量条件判断；将不同状态的行为封装到独立的状态类中。
- **使用场景**：对象的行为依赖于其状态时，如有限状态机、游戏角色状态管理等。

**21. 访问者模式 (Visitor Pattern)**

- **目的**：将操作从对象结构中分离出来，使得可以在不改变对象结构的情况下添加新的操作。
- **特点**：使得增加新的操作变得容易；将相关操作集中管理。
- **使用场景**：需要对一个对象结构中的各个元素执行不同而又相关的操作时，如编译器语法树的遍历与处理。

**22. 中介者模式 (Mediator Pattern)**

- **目的**：用一个中介对象来封装一系列对象交互，从而使各对象不需要直接引用彼此，降低耦合。
- **特点**：集中控制对象间的交互；降低系统复杂度，便于维护和扩展。
- **使用场景**：当系统中对象之间存在复杂交互时，如聊天系统中的消息调度、航空调度系统等。

**23. 解释器模式 (Interpreter Pattern)**

- **目的**：给定一个语言，定义其文法的一种表示，并实现一个解释器来解释这种语言中的句子。
- **特点**：易于扩展语言功能；适用于语法规则较简单的场合。
- **使用场景**：编译器、脚本语言解释器、规则引擎等。
